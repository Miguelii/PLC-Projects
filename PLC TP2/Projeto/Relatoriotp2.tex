\documentclass[11pt,a4paper]{report}%especifica o tipo de documento que tenciona escrever: carta, artigo, relatório... neste caso é um relatório
% [11pt,a4paper] Define o tamanho principal das letras do documento. caso não especifique uma delas, é assumido 10pt
% a4paper -- Define o tamanho do papel.

\usepackage[portuges]{babel}%Babel -- irá activar automaticamente as regras apropriadas de hifenização para a língua todo o
                                   %-- o texto gerado é automaticamente traduzido para Português.
                                   %  Por exemplo, “chapter” irá passar a “capítulo”, “table of contents” a “conteúdo”.
                                   % portuges -- específica para o Português.
\usepackage[utf8]{inputenc} % define o encoding usado texto fonte (input)--usual "utf8" ou "latin1

\usepackage{graphicx} %permite incluir graficos, tabelas, figuras
\usepackage{url} % para utilizar o comando \url{}
\usepackage{enumerate} %permite escolher, nas listas enumeradas, se os iems sao marcados com letras ou numeros-romanos em vez de numeracao normal

%\usepackage{apalike} % gerar biliografia no estilo 'named' (apalike)

\usepackage{color} % Para escrever em cores
\usepackage{multicol}
\usepackage{multirow} %tabelas com multilinhas
\usepackage{array} %formatação especial de tabelas em array

\usepackage[pdftex]{hyperref} % transformar as referências internas do seu documento em hiper-ligações.

%Exemplos de fontes -- nao e vulgar mudar o tipo de fonte
%\usepackage{tgbonum} % Fonte de letra: TEX Gyre Bonum
%\usepackage{lmodern} % Fonte de letra: Latin Modern Sans Serif
%\usepackage{helvet}  % Fonte de letra: Helvetica
%\usepackage{charter} % Fonte de letra:Charter

\definecolor{saddlebrown}{rgb}{0.55, 0.27, 0.07} % para definir uma nova cor, neste caso 'saddlebrown'

\usepackage{listings}  % para utilizar blocos de texto verbatim no estilo 'listings'
%paramerização mais vulgar dos blocos LISTING - GENERAL
\lstset{
    basicstyle=\small, %o tamanho das fontes que são usadas para o código
    numbers=left, % onde colocar a numeração da linha
    numberstyle=\tiny, %o tamanho das fontes que são usadas para a numeração da linha
    numbersep=5pt, %distancia entre a numeração da linha e o codigo
    breaklines=true, %define quebra automática de linha
    frame=tB,  % caixa a volta do codigo
    mathescape=true, %habilita o modo matemático
    escapeinside={(*@}{@*)} % se escrever isto  aceita tudo o que esta dentro das marcas e nao altera
}
%
%\lstset{ %
%   language=Java,                          % choose the language of the code
%   basicstyle=\ttfamily\footnotesize,      % the size of the fonts that are used for the code
%   keywordstyle=\bfseries,                 % set the keyword style
%   %numbers=left,                          % where to put the line-numbers
%   numberstyle=\scriptsize,                % the size of the fonts that are used for the line-numbers
%   stepnumber=2,                           % the step between two line-numbers. If it's 1 each line
%                                           % will be numbered
%   numbersep=5pt,                          % how far the line-numbers are from the code
%   backgroundcolor=\color{white},          % choose the background color. You must add \usepackage{color}
%   showspaces=false,                       % show spaces adding particular underscores
%   showstringspaces=false,                 % underline spaces within strings
%   showtabs=false,                         % show tabs within strings adding particular underscores
%   frame=none,                             % adds a frame around the code
%   %abovecaptionskip=-.8em,
%   %belowcaptionskip=.7em,
%   tabsize=2,                              % sets default tabsize to 2 spaces
%   captionpos=b,                           % sets the caption-position to bottom
%   breaklines=true,                        % sets automatic line breaking
%   breakatwhitespace=false,                % sets if automatic breaks should only happen at whitespace
%   title=\lstname,                         % show the filename of files included with \lstinputlisting;
%                                           % also try caption instead of title
%   escapeinside={\%*}{*)},                 % if you want to add a comment within your code
%   morekeywords={*,...}                    % if you want to add more keywords to the set
%}

\usepackage{xspace} % deteta se a seguir a palavra tem uma palavra ou um sinal de pontuaçao se tiver uma palavra da espaço, se for um sinal de pontuaçao nao da espaço

\parindent=0pt %espaço a deixar para fazer a  indentação da primeira linha após um parágrafo
\parskip=2pt % espaço entre o parágrafo e o texto anterior

\setlength{\oddsidemargin}{-1cm} %espaço entre o texto e a margem
\setlength{\textwidth}{18cm} %Comprimento do texto na pagina
\setlength{\headsep}{-1cm} %espaço entre o texto e o cabeçalho
\setlength{\textheight}{23cm} %altura do texto na pagina

% comando '\def' usado para definir abreviatura (macros)
% o primeiro argumento é o nome do novo comando e o segundo entre chavetas é o texto original, ou sequência de controle, para que expande
\def\darius{\textsf{Darius}\xspace}
\def\antlr{\texttt{AnTLR}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}
\def\titulo#1{\section{#1}}    %no corpo do documento usa-se na forma '\titulo{MEU TITULO}'
\def\super#1{{\em Supervisor: #1}\\ }
\def\area#1{{\em \'{A}rea: #1}\\[0.2cm]}
\def\resumo{\underline{Resumo}:\\ }

%\input{LPgeneralDefintions} %permite ler de um ficheiro de texto externo mais definições

\title{Processamento de Linguagens e Compiladores\\
       \textbf{Trabalho Prático 2}\\ Relatório de Desenvolvimento
       } %Titulo do documento
%\title{Um Exemplo de Artigo em \LaTeX}
\author{Miguel Gonçalves\\ a90416 \and João Nogueira\\ a87973
         \and Rui Baptista\\ a87989
       } %autores do documento
\date{\today} %data

\begin{document} % corpo do documento
\maketitle % apresentar titulo, autor e data

\begin{abstract}  % resumo do documento
O seguinte relatório documenta, justifica, analisa e expõe todas as decisões tomadas ao longo do Trabalho Pratico 2 realizado no âmbito da Unidade Curricular denominada Processamento de Linguagens e Compiladores no contexto do 3º ano do curso Licenciatura em Ciências da Computação. O seguinte trabalho tem como principais objetivos aumentar a experiência em engenharia de linguagens e em programação generativa, desenvolver processadores de linguagens segundo o método da tradução dirigida pela sintaxe, desenvolver um compilador gerando código para uma máquina de stack virtual e utilizar geradores de compiladores baseados em gramáticas tradutoras. 
\end{abstract}

\tableofcontents % Insere a tabela de indice
%\listoffigures % Insere a tabela de indice figuras
%\listoftables % Insere a tabela de indice tabelas

\chapter{Introdução} \label{chap:intro} %referência cruzada
\titulo{Compilador em Yacc}

Este trabalho tem como objetivo desenvolver um compilador para a nossa própria linguagem, fazendo a tradução entre o código da nossa linguagem, de acordo com as regras estipuladas para a mesma, para código Assembly da VM.
De forma a desenvolver uma linguagem imperativa simples, foram tomadas decisões à cerca de como apresentar e declarar as variáveis inteiras, como definir as habituais operações aritméticas, relacionais e lógicas, e ainda outras “regras” essenciais para o iminente funcionamento da linguagem criada. Todas estas decisões foram devidamente discutidas e tomadas em grupo, com unanimidade.
Para melhor compreensão de como funciona a linguagem desenvolvida, serão apresentados alguns exemplos da própria em funcionamento.


\begin{center}
    \includegraphics[width=1\textwidth]{int.png}
    \\
    \caption{Figura 1. Fluxograma que ilustra o processo de tradução código fonte para código VM}
\end{center}

\chapter{Análise do problema} \label{chap:analiseEspecificacao} %capitulo e referencia cruzada
\section{Descrição informal do problema} \label{sec:descricaoProblema} %seccao e referencia cruzada

No enunciado era pedido para criar uma linguagem imperativa a nosso gosto, mas que devia
permitir fazer o seguinte:

\begin{enumerate}
\item Declarar variaveis atomicas do tipo inteiro, com os quais se podem realizar as habituais operações aritmeticas.

\item Efetuar instruções algorítmicas básicas como a atribuição do valor de expressões numéricas a variáveis

\item Ler do stdin e escrever no stdout

\item Efetuar instruções cíclicas para controlo do fluxo de execução, permitindo o seu aninhamento (Implementar pelo menos o ciclo while-do, repeat-until ou for-do).
\end{enumerate}

Adicionalmente deve ainda suportar, à sua escolha, uma das duas funcionalidades seguintes:

\begin{enumerate}
\item [5.] Declarar e manusear variáveis estruturadas do tipo array (a 1 ou 2 dimensões) de inteiros.
\item [6.] Definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado do tipo inteiro.
\end{enumerate}

Relativamente à escolha das 2 funcionalidades extra, decidimos escolhemos declarar e manusear variáveis estruturadas do tipo array.

\newpage

\chapter{Analisador léxico (Flex)}

Inicialmente foi criado um analisador léxico, utilizando a ferramenta flex, que permite processar o código fonte, contendo um programa escrito na nossa linguagem. Durante este processamento, são retornados diferentes tokens, correspondentes a expressões regulares que identificam padrões do nosso código.
\\
\\
\textbf{Palavras Reservadas} 
\\
Ao longo do código, existem expressões utilizadas diretamente pela linguagem, designadas por "palavras reservadas".

\begin{lstlisting}[frame=single,numbers=none]
reserved = {
   'se' : 'IF',
   'else' : 'ELSE',
   'enquanto' : 'WHILE',
   'num' : 'DCLN',
   'string' : 'DCLS',
   'desde' : 'FOR',
   'ate' : 'UNTIL',
   'imprime' : 'PRINT',
   'le' : 'SCAN',
   'devolve' : 'RETURN',
   'lista' : 'ARRAY'
}

tokens = [
    'LPAREN',
    'RPAREN',
    'VIRG',
    'ID',
    'BOOL', 
    'NUM',
    'SOMA',
    'SUBTRACAO',
    'MULTIPLICACAO',
    'DIVISAO',
    'IGUAL',
    'CONJUNCAO',
    'DISJUNCAO',
    'DOISPONTOS',
    'MAIOR',
    'MENOR',
    'ASPAS',
    'REAL',
    'PRE',
    'PRD',
    'MOD',
]
\end{lstlisting}

Quando estas são identificadas, os seus tokens são devolvidos.
\\
\begin{lstlisting}[frame=single,numbers=none]
t_MOD       = r'%'
t_PRE       = r'\['
t_PRD       = r'\]'
t_ASPAS     = r'"'
t_DOISPONTOS= r'\:'
t_IGUAL     = r'\='
t_LPAREN    = r'\('
t_RPAREN    = r'\)'
t_VIRG      = r','
t_CONJUNCAO = r'\&'
t_DISJUNCAO = r'\|' 
t_SOMA      = r'\+'
t_SUBTRACAO = r'-'
t_MULTIPLICACAO = r'\*'
t_DIVISAO   = r'\/'
t_MAIOR     = r'>'
t_MENOR     = r'<'

def t_ID(t):
    r'[a-zA-Z_][a-zA-Z_0-9]*'
    return t

def t_REAL(t): 
    r'(([1-9]+\.[0-9]+)|(0\.[0-9]+))'
    return t

def t_NUM(t): 
    r'([0-9]+)'
    return t 
    
def t_BOOL(t): 
    r'True|False'
    return t
\end{lstlisting}

\chapter{Concepção da Solução (Yacc)}

A nossa linguagem é baseada na grande maioria em pseudocódigo, acreditamos que, a nosso ver, torna certas funcionalidades mais simpáticas e simples de serem escritas.


\section{Declaração de variáveis}

A linguagem permite a declaração de variáveis do tipo número, string e arrays. Em Yacc definimos que podemos atribuir um valor a estas variáveis ou sempre que é declarada sem ser feita essa atribuição, é-lhe atribuído o valor 0.
\\
\\
Vamos ver agora um exemplo de uma declaração de variável do tipo número sem ser feito qualquer atribuição. Esta implementação está escrita em Yacc da seguinta forma:

\begin{verbatim}
def p_declararNumSolo(p): 
    'declara : DCLN ID'
\end{verbatim}

Assim temos:

\begin{lstlisting}[frame=single,numbers=none]
num i
\end{lstlisting}

Podemos também atribuir um valor a essa variável adicionando "IGUAL" e "expression"  à implementação em Yacc.

\begin{verbatim}
def p_declararNum(p): 
    'declara : DCLN ID IGUAL expression'
\end{verbatim}

Desta forma, temos:

\begin{lstlisting}[frame=single,numbers=none]
num i = 1 
\end{lstlisting}

\newpage 

\section{Calculo de expressões}

A nossa linguagem permite as habituais operações aritméticas, relacionais e lógicas.

\begin{enumerate}

\item Típicas operações de verificação de igualdades/desigualdades ("=="), ("$<$"), ("$>$"), ("$\leq$") e ("$\geq$").
\item Multiplicação ("*"), divisão ("/") e módulo ("\%").
\item Soma ("+") e subtração ("$-$").
\item Operações booleanas de conjunção ("\&") e disjunção ("$|$").

\end{enumerate}

Por exemplo, para soma, subtração e divisão a implementação em Yacc foi feita da seguinte forma:

\begin{verbatim}
def p_soma(p):
    'expression : expression SOMA term'
    
def p_somaId(p): 
    'expression : expression SOMA ID'
    
def p_subtracao(p):
    'expression : expression SUBTRACAO term'
    
def p_subtracaoId(p): 
    'expression : expression SUBTRACAO ID'
    
def p_divisao(p):

    'expression : expression DIVISAO term'
def p_divisaoId(p): 
    'expression : expression DIVISAO ID'
\end{verbatim}

No Apêndice B encontra-se o restante código Yacc para o resto das operações,
\\
\\
A título de exemplo, uma atribuição a uma variável pode ser feita da seguinte forma:
\\
\begin{lstlisting}[frame=single,numbers=none]
num x = 6
num y = x%2

se y==0:
    (num c = c+1)
\end{lstlisting}

\newpage

\section{Standard input e output}

Tal como é pedido no enunciado do trabalho, a nossa linguagem permite ler do standard input e escrever no standard output. Seguindo o objetivo da linguagem, que é ser simpática e simples de escrever, no caso de ler do standard input, definimos da seguinte forma em Yacc:

\begin{verbatim}
def p_scan(p): 
    'scan : SCAN LPAREN ID RPAREN'
\end{verbatim}

Ou seja, se quisermos ler, por exemplo, um tipo inteiro podemos fazer da seguinte forma:

\begin{lstlisting}[frame=single,numbers=none]
num n 
le(n)
\end{lstlisting}

Para escrever no standard output, temos várias opções na linguagem. Podemos escrever um termo, uma espressão, um id ou fazer um composto que contém um id e espressão. Em Yacc estão definidos da seguinte forma:

\begin{verbatim}
def p_printId(p): 
    'print : PRINT LPAREN ID RPAREN'
    
def p_print(p): 
    'print : PRINT LPAREN ASPAS ID ASPAS RPAREN'
    
def p_printN(p): 
    'print : PRINT LPAREN ASPAS term ASPAS RPAREN'

def p_printComposto(p): 
    'print : PRINT LPAREN ASPAS ID ASPAS VIRG expression RPAREN'

def p_printExpressao(p):
    'print : PRINT LPAREN expression RPAREN'
\end{verbatim}

Desta forma, permite-nos fazer os seguintes exemplos:

\begin{lstlisting}[frame=single,numbers=none]
num x = 5
imprime(x)
\end{lstlisting}

\begin{lstlisting}[frame=single,numbers=none]
imprime("Texto aqui")
\end{lstlisting}


\section{Ciclos}

Falando agora de instruções cíclicas, no enunciado do problema pedia para implementar pelo menos o ciclo while-do, repeat-until ou for-do. O nosso grupo decidiu implementar os 3 tipos de ciclos.

\subsection{Ciclo For}
Queremos que os ciclos sejam simpáticos de escrever e fáceis de entender. Sendo assim, o ciclo for foi implementado em Yacc da seguinte maneira:

\begin{verbatim}
def p_cicloFor(p): 
    'for : FOR ID UNTIL comparacoes VIRG sinal NUM DOISPONTOS LPAREN statements RPAREN'
\end{verbatim}

Como exemplo desta implementação temos o seguinte código:
\\
\begin{lstlisting}[frame=single,numbers=none]
num i 
desde i ate i<6,+1: (imprime(i))
\end{lstlisting}


Ou seja, desde i até i $<$ 6 em incrementos de 1.
\\
\\
Ao adicionar aquele "sinal" \ à implementação do Yacc significa que o nosso ciclo for consegue também andar para trás, sendo possivel fazer algo assim:
\\
\begin{lstlisting}[frame=single,numbers=none]
num i = 5
desde i ate i>0,-1: (imprime(i))
\end{lstlisting}

Como podemos verificar, a linguagem permite a fácil interpretação do código, um dos nossos objetivos principais.


\subsection{Ciclo If}

Para a implementação do ciclo If temos 2 opções, um If que contém depois um Else e outro que tem apenas If. Ambos estão escritos em Yacc da seguinta forma:

\begin{verbatim}
def p_cicloIf(p): 
    'if : IF tipos DOISPONTOS LPAREN statements RPAREN ELSE LPAREN statements RPAREN'

def p_cicloIfSolo(p):
    'if : IF tipos DOISPONTOS LPAREN statements RPAREN'
\end{verbatim}

Para exemplo do ciclo If, temos o seguinte código:
\\
\begin{lstlisting}[frame=single,numbers=none]
num x = 0 
num y

se x==1: (y=2) else (y=x)

devolve(y)
\end{lstlisting}


\subsection{Ciclo While}

O ciclo While está escrito em Yacc da seguinte forma:

\begin{verbatim}
def p_cicloWhile(p):
    'while : WHILE tipos DOISPONTOS LPAREN statements RPAREN'
\end{verbatim}

Como exemplo temos o seguinte código:
\\
\begin{lstlisting}[frame=single,numbers=none]
num i 

enquanto i<2: (i = i+1)

devolve(i)
\end{lstlisting}

\section{Arrays}

Como já tinhamos falado no capítulo de Declaração de variávies, a nossa linguagem permite também declarar e manusear variáveis estruturadas do tipo array. A declaração de um array está escrita em Yacc da seguinte maneira:

\begin{verbatim}
def p_declararArray(p): 
    'declara : ARRAY PRE NUM PRD ID'
\end{verbatim}

Permitindo declarações assim:
\\
\begin{lstlisting}[frame=single,numbers=none]
lista [10] v
\end{lstlisting}


De forma a permitir manusear estas variáveis, através de atribuições, implementamos em Yacc as seguintes definições:

\begin{verbatim}
def p_atribuicaoArray(p):
    'atribuicao : ID PRE NUM PRD IGUAL expression'

def p_atribuicaoArrayID(p):
    'atribuicao : ID PRE ID PRD IGUAL expression'

def p_atribuicaoIdArray(p):
    'atribuicao : ID IGUAL ID PRE ID PRD'

def p_atribuicaoNumArray(p):
    'atribuicao : ID IGUAL ID PRE NUM PRD'
\end{verbatim}

Desta forma, a linguagem permite fazer atribuições do seguinte tipo:
\\
\begin{lstlisting}[frame=single,numbers=none]
lista [10] v
num x = 5
num i = 1

v[i] = x 

x = v[i]
\end{lstlisting}


\chapter{Gerar código Assembly}

Um ponto importante do trabalho é o compilador gerar automaticamente código Assembly, para depois ser usado pela VM. Para tal, aplicamos os conhecimentos adquiridos nas aulas e ao longo do código Yacc fomos adicionando os respetivos comandos assembly, como é visível no apêndice B. 
\\
Para provar o bom funcionamento do programa, temos o seguinte exemplo onde vamos declarar duas variáveis e realizar um ciclo, o compilador vai então gerar o seguinte código assembly:

\begin{center}
    \includegraphics[width=.3\textwidth]{bb.png}
    \\
    \caption{Figura 2. Exemplo código assembly}
\end{center}

Para tal, o ciclo If está implementado em Yacc da seguinte forma:

\begin{verbatim}
def p_cicloIf(p): 
    'if : IF tipos DOISPONTOS LPAREN statements RPAREN ELSE LPAREN statements RPAREN'
    global nroIf
    aux = nroIf + 1 
    p[0] = p[2] + r'JZ L' + str(nroIf) + '\n' + p[5] + '\nJUMP L' + str(aux) + '\nL' + 
    str(nroIf) + ':\n' + p[9] + '\nL' + str(aux) + ':\n'
\end{verbatim}

\chapter{Testes e Exemplos}

\section{Ler 4 números e dizer se podem ser os lados de um quadrado}

\subsection{Código}
Para este problema temos o seguinte código escrito na nossa linguagem:.
\\
\begin{lstlisting}[frame=single,numbers=none]
num x 
num y 
num z 
num w 
imprime("variavel")
le(x)
imprime("variavel")
le(y)
imprime("variavel")
le(z)
imprime("variavel")
le(w)
num r = 0
num soma = 0
se x==y:(soma = soma +1)
se y==z:(soma = soma +1)
se z==w:(soma = soma +1)
se soma==3:(r=1)
devolve(r)
\end{lstlisting}

\subsection{Assembly gerado}

A linguagem vai gerar o seguinte código Assembly:

\begin{lstlisting}[frame=single,numbers=none]
START
PUSHI 0
PUSHI 0
PUSHI 0
PUSHI 0
PUSHS "variavel"
WRITES
READ
ATOI
STOREG 0
PUSHS "variavel"
WRITES
READ
ATOI
STOREG 1
PUSHS "variavel"
WRITES
READ
ATOI
STOREG 2
PUSHS "variavel"
WRITES
READ
ATOI
STOREG 3
PUSHI 0

PUSHI 0

PUSHG 0
 
PUSHG 1
EQUAL
JZ L0
PUSHG 5
 
PUSHI 1

ADD
STOREG 5

JUMP L0
L0:
PUSHG 1
 
PUSHG 2
EQUAL
JZ L2
PUSHG 5
 
PUSHI 1

ADD
STOREG 5

JUMP L2
L2:
PUSHG 2
 
PUSHG 3
EQUAL
JZ L4
PUSHG 5
 
PUSHI 1

ADD
STOREG 5

JUMP L4
L4:
PUSHG 5
 
PUSHI 3
EQUAL
JZ L6
PUSHI 1
STOREG 4

JUMP L6
L6:
PUSHG 4

PUSHS "O return é: "
WRITES
WRITEI
STOP 
\end{lstlisting}


\subsection{Máquina virtual VM}

Vamos agora passar o ficheiro com o código assembly gerado à VM e ver o seu comportamento.
A VM vai pedir para introduzir 4 valores e dá return 1 se forem todos iguais (lados de um quadrado) e 0 senão. Para correr a VM em modo de texto fazemos:

\begin{verbatim}
> ./vms [nome do ficheiro]
\end{verbatim}

\begin{center}
    \includegraphics[width=.5\textwidth]{a1.png}
    \\
    \caption{Figura 3. Exemplo do programa 6.1 na VM - Modo texto}
\end{center}

\begin{center}
    \includegraphics[width=.5\textwidth]{a0.png}
    \\
    \caption{Figura 4. Exemplo do programa na 6.1 VM - Modo texto}
\end{center}

\newpage

Podemos também correr a maquina em modo gráfico com:

\begin{verbatim}
> ./vms -g [nome do ficheiro]
\end{verbatim}

\begin{center}
    \includegraphics[width=.8\textwidth]{aa.png}
    \\
    \caption{Figura 5. Exemplo do programa 6.1 na VM - Modo Gráfico}
\end{center}

\section{Ler um inteiro N, Depois ler N números e escrever o menor deles}

\subsection{Código}
Para este problema temos o seguinte código escrito na nossa linguagem:
\\
\begin{lstlisting}[frame=single,numbers=none]
num n 
le(n)
num y = 0
num m 
num x 
num i = 1 
desde i ate i<n+1,+1: 
    (
    le(x)
    se y==0: (
        m = x
        y = 1     
        )
    else (
        se x<m: (
            m = x
        )
    )
    )
devolve(m)
\end{lstlisting}

\subsection{Assembly gerado}

A linguagem vai gerar o seguinte código Assembly:

\begin{lstlisting}[frame=single,numbers=none]
START
PUSHI 0
READ
ATOI
STOREG 0
PUSHI 0

PUSHI 0
PUSHI 0
PUSHI 1

CICLO0:
PUSHG 4
 
PUSHG 0
 
PUSHI 1

ADD
INF
JZ FIM0
READ
ATOI
STOREG 3
PUSHG 1
 
PUSHI 0
EQUAL
JZ L2
PUSHG 3
STOREG 2
PUSHI 1
STOREG 1

JUMP L3
L2:
PUSHG 3
 
PUSHG 2
INF
JZ L0
PUSHG 3
STOREG 2

JUMP L0
L0:

L3:
PUSHG 4
PUSHI 1
ADD

STOREG 4
JUMP CICLO0
FIM0:
PUSHG 2

PUSHS "O return é: "
WRITES
WRITEI
STOP 
\end{lstlisting}

\subsection{Máquina virtual VM}

Como pedido, introduzimos primeiramente um inteiro N, neste caso 5, e depois introduzimos 5 números (1,2,9,6 e 7) e vai return ao menor, neste caso é o 1.
\begin{center}
    \includegraphics[width=.5\textwidth]{b1.png}
    \\
    \caption{Figura 6. Exemplo do programa 6.2 na VM - Modo texto}
\end{center}
\\
Outro exemplo, agora sendo o N = 10 e os numeros introduzidos 3,8,9,6,7,11,12,5,14,16.
\begin{center}
    \includegraphics[width=.5\textwidth]{b2.png}
    \\
    \caption{Figura 7. Exemplo do programa 6.2 na VM - Modo texto}
\end{center}

\newpage

\section{Ler N (constante do programa) números e calcular e imprimir o seu produtório}

\subsection{Código}

Para este problema temos o seguinte código escrito na nossa linguagem:
\\
\begin{lstlisting}[frame=single,numbers=none]
num n 
le(n)
num i = 1 
num x
num r = 1 

desde i ate i<n+1,+1: (
    le(x)
    num r = r * x 
)

devolve(r)
\end{lstlisting}

\subsection{Assembly gerado}

A linguagem vai gerar o seguinte código Assembly:

\begin{lstlisting}[frame=single,numbers=none]
START
PUSHI 0
READ
ATOI
STOREG 0
PUSHI 1

PUSHI 0
PUSHI 1

CICLO0:
PUSHG 1
 
PUSHG 0
 
PUSHI 1

ADD
INF
JZ FIM0
READ
ATOI
STOREG 2
PUSHG 3

PUSHG 2
MUL

STOREG 3
PUSHG 1
PUSHI 1
ADD

STOREG 1
JUMP CICLO0
FIM0:
PUSHG 3

PUSHS "O return é: "
WRITES
WRITEI
STOP 
\end{lstlisting}

\subsection{Máquina virtual VM}

Começamos então por introduzir um N, neste exemplo será 5, e depois 5 vezes o número 3. Como podemos verificar 3x3x3x3x3 = 243.
\begin{center}
    \includegraphics[width=.5\textwidth]{c1.png}
    \\
    \caption{Figura 8. Exemplo do programa 6.3 na VM - Modo texto}
\end{center}

Sendo agora N = 3 e os números introduzidos 3,2,1. Logo 3x2x1 = 6.

\begin{center}
    \includegraphics[width=.5\textwidth]{c2.png}
    \\
    \caption{Figura 9. Exemplo do programa 6.3 na VM - Modo texto}
\end{center}

\newpage

\section{Contar e imprimir os números impares de uma sequência de números naturais}

\subsection{Código}

Para este problema temos o seguinte código escrito na nossa linguagem:
\\
\begin{lstlisting}[frame=single,numbers=none]
num n 
le(n)
num c 
num x 
num y
num i

desde i ate i<n,+1:(
    le(x)
    num y = x%2
    se y==0: 
    (imprime("par"))
    else (
        num c = c+1 
        imprime("impar")
    )
)
devolve(c)
\end{lstlisting}

\subsection{Assembly gerado}

\begin{lstlisting}[frame=single,numbers=none]
START
PUSHI 0
READ
ATOI
STOREG 0
PUSHI 0
PUSHI 0
PUSHI 0
PUSHI 0
CICLO0:
PUSHG 4
 
PUSHG 0
INF
JZ FIM0
READ
ATOI
STOREG 2
PUSHG 2
PUSHI 2
MOD

STOREG 3
PUSHG 3
 
PUSHI 0
EQUAL
JZ L0


JUMP L1
L0:
PUSHG 1
 
PUSHI 1

ADD

STOREG 1
PUSHS "impar"
WRITES

L1:
PUSHG 4
PUSHI 1
ADD

STOREG 4
JUMP CICLO0
FIM0:
PUSHG 1

PUSHS "O return é: "
WRITES
WRITEI
STOP
\end{lstlisting}

\subsection{Máquina virtual VM}

Começamos por introduzir um N, neste exemplo será 10, e depois os números de 1 até 10. Como sabemos existe 5 ímpares (1,3,5,6,9) e é esse número que o programa devolve. Ao longo da execução vamos dando print se o número é par ou ímpar.
\begin{center}
    \includegraphics[width=.5\textwidth]{d1.png}
    \\
    \caption{Figura 10. Exemplo do programa 6.4 na VM - Modo texto}
\end{center}

Sendo agora N = 5, vamos apenas introduzir números pares para ver se o programa retorna 0.
\begin{center}
    \includegraphics[width=.5\textwidth]{d2.png}
    \\
    \caption{Figura 11. Exemplo do programa 6.4 na VM - Modo texto}
\end{center}

\section{Ler e armazenar N números num array e imprimir os valores por ordem inversa}

\subsection{Código}

Para este problema temos o seguinte código escrito na nossa linguagem:
\\
\begin{lstlisting}[frame=single,numbers=none]
num n
le(n)
num i 
num x 
lista [10] v

desde i ate i<n,+1: (
    le(x)
    v[i] = x
)

i = n-1
desde i ate i>=0,-1:(
    x=v[i]
    imprime(x)
    se i==0: ()
    else (
    imprime(,)
    )
)
\end{lstlisting}


\subsection{Assembly gerado}

\begin{lstlisting}[frame=single,numbers=none]
START
PUSHI 0
READ
ATOI
STOREG 0
PUSHI 0
PUSHI 0
PUSHN 10
CICLO0:
PUSHG 1
 
PUSHG 0
INF
JZ FIM0
READ
ATOI
STOREG 2
PUSHGP
PUSHI 3
PADD
PUSHG 1
PUSHG 2

STOREN
PUSHG 1
PUSHI 1
ADD

STOREG 1
JUMP CICLO0
FIM0:
PUSHG 0
 
PUSHI 1

SUB
STOREG 1
CICLO2:
PUSHG 1
 
PUSHI 0
SUPEQ
JZ FIM2
PUSHGP
PUSHI 3
PADD
PUSHG 1
LOADN
STOREG 2
PUSHG 2
STRI
WRITES
PUSHG 1
 
PUSHI 0
EQUAL
JZ L0


JUMP L1
L0:
PUSHS ","
WRITES

L1:
PUSHG 1
PUSHI 1
SUB

STOREG 1
JUMP CICLO2
FIM2:
STOP 
\end{lstlisting}

\subsection{Máquina virtual VM}

Sendo então N = 10, inserimos os números de 1 a 10 e verificamos que o programa dá print aos valores corretamente por ordem inversa.
\begin{center}
    \includegraphics[width=.5\textwidth]{e2.png}
    \\
    \caption{Figura 12. Exemplo do programa 6.5 na VM - Modo texto}
\end{center}


\chapter{Conclusão} \label{concl}
A oportunidade de desenvolver a nossa própria linguagem de programação foi algo inédito na nossa carreira académica enquanto alunos de Ciências da Computação.
\\
\\
Foi um processo desafiante, com atenção ao detalhe de forma a garantir o funcionamento de cada pormenor da linguagem, para haver a certeza do funcionamento da linguagem como um todo.
Um ponto bastante importante quando se utiliza uma linguagem é a forma como esta se conecta com o seu utilizador, ou seja, a forma como reage perante o mesmo. De acordo com a nossa experiência anteriormente adquirida na utilização de diferentes linguagens, tentámos tornar esta em particular bastante user friendly, de forma que seja bastante simples de usar e entender. 
\\
\\
A dificuldade de certos programas, em alguns casos, não está na sua resolução, ou pelo menos não no raciocínio da resolução, mas sem na dificuldade em aplicar essa resolução à gramática em questão.
Embora a nossa linguagem não seja de todo complexa, o processo da sua criação permitiu-nos adquirir conhecimentos acerca de várias técnicas como parsing, a tradução de código para VM e a compilação do próprio código.
\\
\\
Podemos assim concluir que apesar da baixa complexidade da linguagem gerada, todas as etapas até à criação da mesma foram bastante frutíferas no que toca a adquirir conhecimento sobre o seu funcionamento, as suas limitações e pontos fortes.
\\
\\
Poder efetuar operações numa linguagem escrita por nós é sem dúvida um sentimento único, de reconhecimento e orgulho no nosso trabalho.


\appendix % apendice

\chapter{Código Flex}


\begin{lstlisting}
import ply.lex as lex
import sys

reserved = {
   'se' : 'IF',
   'else' : 'ELSE',
   'enquanto' : 'WHILE',
   'num' : 'DCLN',
   'string' : 'DCLS',
   'desde' : 'FOR',
   'ate' : 'UNTIL',
   'imprime' : 'PRINT',
   'le' : 'SCAN',
   'devolve' : 'RETURN',
   'lista' : 'ARRAY'
}

tokens = [
    'LPAREN',
    'RPAREN',
    'VIRG',
    'ID',
    'BOOL', 
    'NUM',
    'SOMA',
    'SUBTRACAO',
    'MULTIPLICACAO',
    'DIVISAO',
    'IGUAL',
    'CONJUNCAO',
    'DISJUNCAO',
    'DOISPONTOS',
    'MAIOR',
    'MENOR',
    'ASPAS',
    'REAL',
    'PRE',
    'PRD',
    'MOD',
] + list(reserved.values())

t_MOD       = r'%'
t_PRE       = r'\['
t_PRD       = r'\]'
t_ASPAS     = r'"'
t_DOISPONTOS= r'\:'
t_IGUAL     = r'\='
t_LPAREN    = r'\('
t_RPAREN    = r'\)'
t_VIRG      = r','
t_CONJUNCAO = r'\&'
t_DISJUNCAO = r'\|' 
t_SOMA      = r'\+'
t_SUBTRACAO = r'-'
t_MULTIPLICACAO = r'\*'
t_DIVISAO   = r'\/'
t_MAIOR     = r'>'
t_MENOR     = r'<'


def t_ID(t):
    r'[a-zA-Z_][a-zA-Z_0-9]*'
    t.type = reserved.get(t.value,'ID')    # Check for reserved words
    return t

def t_REAL(t): 
    r'(([1-9]+\.[0-9]+)|(0\.[0-9]+))'
    return t

def t_NUM(t): 
    r'([0-9]+)'
    return t 

def t_BOOL(t): 
    r'True|False'
    return t

t_ignore = ' \r\n\t'
def t_error(t):
    print('Illegal character: ' + t.value[0])
    t.lexer.skip
    t.lexer.skip(1)


lexer = lex.lex() # cria um AnaLex especifico a partir da especificação acima usando o gerador 'lex' do objeto 'lex'
\end{lstlisting}

\newpage

\chapter{Código Yacc}

\begin{lstlisting}
import ply.yacc as yacc
import sys
from myLanguageLex import tokens 
 
global store 
global nroIf
global nroWhile
global nroFor
variaveis = {}
array = {}

nroWhile = 0
nroIf = 0
nroFor = 0 
store = 0

def p_final(p): 
    'final : reconhece'
    p[0] = r'START' + '\n' + p[1] +  r'STOP '+ '\n'
    print(p[0])

def p_reconhece(p): 
    '''reconhece : tipos
                 | declara
                 | ciclos
                 | print
                 | scan
                 | devolve
                 | atribuicao
    '''
    p[0] = p[1] 

def p_reconheceComposto(p): 
    '''reconhece : tipos reconhece
                 | declara reconhece
                 | ciclos reconhece 
                 | print reconhece
                 | scan reconhece
                 | atribuicao reconhece
    '''
    p[0] =p[1] + p[2] 

def p_multiplicacao(p):
    'expression : expression MULTIPLICACAO term'
    p[0] = p[1] + ' \n' + p[3] + '\n' + r'MUL' + '\n'

def p_multiplicacaoId(p): 
    'expression : expression MULTIPLICACAO ID'
    if p[3] in variaveis: 
        p[0] = p[1] + '\n' + r'PUSHG ' + str(variaveis[p[3]]) + '\n' +  r'MUL' + '\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_divisao(p):
    'expression : expression DIVISAO term'
    p[0] = p[1] + ' \n' + p[3] + '\n' + r'DIV' + '\n'

def p_divisaoId(p): 
    'expression : expression DIVISAO ID'
    if p[3] in variaveis: 
        p[0] = p[1] + '\n' + r'PUSHG ' + str(variaveis[p[3]]) + '\n' + r'DIV' + '\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_somaId(p): 
    'expression : expression SOMA ID'
    if p[3] in variaveis: 
        p[0] = p[1] + '\n' + r'PUSHG ' + str(variaveis[p[3]])  + '\n' + r'ADD' + '\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'
 
def p_soma(p):
    'expression : expression SOMA term'
    p[0] = p[1] + ' \n' + p[3] + '\n' + r'ADD' + '\n'

def p_subtracao(p):
    'expression : expression SUBTRACAO term'
    p[0] = p[1] + ' \n' + p[3] + '\n' + r'SUB' + '\n'

def p_subtracaoId(p): 
    'expression : expression SUBTRACAO ID'
    if p[3] in variaveis: 
        p[0] = p[1] + '\n' + r'PUSHG ' + str(variaveis[p[3]])  + '\n' + r'SUB' + '\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_modulo(p): 
    'expression : NUM MOD NUM'
    p[0] = r'PUSHI ' + str(int(p[1])) + '\n' + r'PUSHI ' + str(int(p[3])) + '\nMOD\n'

def p_moduloId(p): 
    'expression : ID MOD NUM'
    if p[1] in variaveis: 
        p[0] = r'PUSHG ' + str(variaveis[p[1]]) + '\n' + r'PUSHI ' + str(int(p[3])) + '\nMOD\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_moduloNUMId(p): 
    'expression : NUM MOD ID'
    if p[3] in variaveis:
        p[0] = r'PUSHI ' + str(int(p[1])) + '\n' + r'PUSHG ' + str(variaveis[p[3]]) +'\nMOD\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_moduloIdID(p): 
    'expression : ID MOD ID'
    if p[1] in variaveis and p[3] in variaveis:
        p[0] = r'PUSHG ' + str(variaveis[p[1]]) +  r'PUSHG ' + str(variaveis[p[3]]) + 'MOD\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_fator(p):
    'factor : NUM'
    p[0] = r'PUSHI ' + str(int(p[1])) + '\n'

def p_fatorReal(p):
    'factor : REAL'
    p[0] = r'PUSHI ' + str(int(p[1])) + '\n'

def p_termo(p):
    'term : factor'
    p[0] = p[1]

def p_expressao(p):
    'expression : term'
    p[0] = p[1]
    
def p_expressaoId(p): 
    'expression : ID'
    if (p[1] in variaveis):
        p[0] = r'PUSHG ' + str(variaveis[p[1]]) + '\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_elementosC(p):
    '''els : comparacoes
             | term 
    '''
    p[0] = p[1]

def p_elementosUnicos(p): 
    '''els : ID
           | BOOL
    '''
    if p[1] == 'True': 
        p[0] = r'PUSHI 1' + '\n'
    elif p[1]=='False': 
        p[0] = r'PUSHI 0' + '\n'
    elif isinstance(p[1],str):  
        if (p[1] in variaveis):
            p[0] = r'PUSHG ' + str(variaveis[p[1]]) + '\n'
        else: 
            p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_atribuicaoArray(p):
    'atribuicao : ID PRE NUM PRD IGUAL expression'
    if p[1] in variaveis: 
        p[0] = r'PUSHGP' + '\nPUSHI 0\n' + 'PADD\n' +'PUSHI ' + str(variaveis[p[1]]+int(p[3])) + '\n' + p[6] + '\nSTOREN\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel nao definida :("' + '\n' + r'ERR' + '\n' 

def p_atribuicaoArrayID(p):
    'atribuicao : ID PRE ID PRD IGUAL expression'
    if p[1] in variaveis and p[3] in variaveis: 
        p[0] = r'PUSHGP' + '\nPUSHI ' + str(store-array[p[1]]) + '\nPADD\n' + 'PUSHG ' + str(variaveis[p[3]]) + '\n' + p[6] + '\nSTOREN\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel nao definida :("' + '\n' + r'ERR' + '\n' 

def p_atribuicaoIdArray(p):
    'atribuicao : ID IGUAL ID PRE ID PRD'
    if p[1] in variaveis and p[3] in variaveis and p[5] in variaveis: 
        p[0] = r'PUSHGP' + '\nPUSHI ' + str(store-array[p[3]]) + '\nPADD\n' + 'PUSHG ' + str(variaveis[p[5]]) + '\nLOADN\n' + 'STOREG ' + str(variaveis[p[1]]) + '\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel nao definida :("' + '\n' + r'ERR' + '\n' 

def p_atribuicaoNumArray(p):
    'atribuicao : ID IGUAL ID PRE NUM PRD'
    if p[1] in variaveis and p[3] in variaveis and p[5] in variaveis: 
        p[0] = r'PUSHGP' + '\nPUSHI ' + str(store-array[p[3]]) + '\nPADD\n' + 'PUSHG ' + str(p[5]) + '\nLOADN\n' + 'STOREG ' + str(variaveis[p[1]]) + '\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel nao definida :("' + '\n' + r'ERR' + '\n' 


def p_declararArray(p): 
    'declara : ARRAY PRE NUM PRD ID'
    global store
    if p[5] not in variaveis: 
        p[0] = r'PUSHN ' + str(p[3]) + '\n'
        variaveis[p[5]] = store
        store += int(p[3])
        array[p[5]] = int(p[3])
    else: 
        p[0] = r'PUSHS "Erro: Variavel ja declarada :(" ' + '\n' + r'ERR' + '\n'

def p_declararNum(p): 
    'declara : DCLN ID IGUAL expression'
    global store
    if p[2] not in variaveis: 
        p[0] = p[4] + '\n'
        variaveis[p[2]] = store
        store += 1
    else: 
        p[0] = p[4] + '\n' + r'STOREG ' + str(variaveis[p[2]]) + '\n'

def p_declararNumSolo(p): 
    'declara : DCLN ID'
    global store
    if p[2] not in variaveis: 
        p[0] = r'PUSHI 0' + '\n'
        variaveis[p[2]] = store
        store += 1
    else: 
        p[0] = r'PUSHI 0' + '\n'

def p_declararString(p): 
    'declara : DCLS ID'
    p[0] = r'PUSHS ' + "" + '\n'
    global store
    if p[2] not in variaveis: 
        p[0] = r'PUSHS ' + "" + '\n'
        variaveis[p[2]] = store
        store += 1
    else: 
        p[0] = r'PUSHS ' + ""+ '\n'

def p_declararStringSolo(p): 
    'declara : DCLS ID IGUAL ASPAS ID ASPAS'
    global store
    if p[2] not in variaveis: 
        p[0] = r'PUSHS ' +  r'"' + p[5] + r'"' + '\n'
        variaveis[p[2]] = store
        store += 1
    else: 
        p[0] = r'PUSHS ' + r'"' + p[4] + r'"' + '\n'

def p_conjuncao(p): 
    '''conjuncao : els CONJUNCAO els
                 | els CONJUNCAO aux
    '''
    p[0] = p[1] + p[3]

def p_disjuncao(p): 
    '''disjuncao : els DISJUNCAO els
                 | els DISJUNCAO aux
    '''
    p[0] = p[1] + p[3]

def p_auxiliar(p):
    '''aux : conjuncao
           | disjuncao
    '''
    p[0] = p[1]

def p_comparacoes(p):
    '''comparacoes : expression IGUAL IGUAL expression
                    | aux IGUAL IGUAL aux
                    | aux MAIOR aux
                    | aux MENOR aux
                    | expression MAIOR expression
                    | expression MENOR expression
                    | term MAIOR term
                    | term MENOR term
                    | term IGUAL IGUAL term 
    '''
    if p[2] == '=':
        p[0] = p[1] + ' \n' + p[4]  + r'EQUAL' + '\n'
    elif p[2] == '<':
        p[0] = p[1] + ' \n' + p[3]  + r'INF' + '\n'
    elif p[2] == '>':
        p[0] = p[1] + ' \n' + p[3]  + r'SUP' + '\n'        
 

def p_comparacoesComIgualdade(p):
    '''comparacoes :  aux MAIOR IGUAL aux
                    | aux MENOR IGUAL aux
                    | expression MAIOR IGUAL expression
                    | expression MENOR IGUAL expression
                    | term MAIOR IGUAL term
                    | term MENOR IGUAL term
    '''
    if p[2] == '<':
        p[0] = p[1] + ' \n' + p[4]  + r'INFEQ' + '\n'
    elif p[2] == '>':
        p[0] = p[1] + ' \n' + p[4]  + r'SUPEQ' + '\n'        
 

def p_tiposExpressao(p): 
    '''tipos : aux
             | expression
             | comparacoes
             | print
             | devolve
             | scan
             | declara
    '''
    p[0] = p[1]

def p_statements(p): 
    'statements : stat'
    p[0] = p[1]

def p_statementsComposto(p):
    'statements : stat statements'
    p[0] = p[1] + p[2]       

def p_stat(p): 
    '''stat : atribuicao 
            | tipos
            | ciclos
    '''
    p[0] = p[1]

def p_statVazia(p): 
    'stat : '
    p[0] = '\n'

def p_atribuicao(p):
    'atribuicao : ID IGUAL expression'
    if p[1] in variaveis: 
        p[0] = p[3] + r'STOREG ' + str(variaveis[p[1]]) + '\n'
    else: 
        p[0] = r'PUSHS "Erro: Variavel nao definida :("' + '\n' + r'ERR' + '\n' 

def p_cicloIf(p): 
    'if : IF tipos DOISPONTOS LPAREN statements RPAREN ELSE LPAREN statements RPAREN'
    global nroIf
    aux = nroIf + 1 
    p[0] = p[2] + r'JZ L' + str(nroIf) + '\n' + p[5] + '\nJUMP L' + str(aux) + '\nL' + str(nroIf) + ':\n' + p[9] + '\nL' + str(aux) + ':\n'

def p_cicloIfSolo(p):
    'if : IF tipos DOISPONTOS LPAREN statements RPAREN'
    global nroIf
    p[0] = p[2] + r'JZ L' + str(nroIf) + '\n' + p[5] + '\nJUMP L' + str(nroIf) + '\nL' + str(nroIf) + ':\n'
    nroIf += 1 

def p_sinal(p): 
    '''sinal : SOMA
               | SUBTRACAO
               | MULTIPLICACAO
               | DIVISAO
    '''
    if p[1] == '+' : 
        p[0] = '\nADD\n'
    elif p[1] == '-' : 
        p[0] = '\nSUB\n'
    elif p[1] == '*' : 
        p[0] = '\nMUL\n'
    elif p[1] == '/' : 
        p[0] = '\nDIV\n'

def p_cicloFor(p): 
    'for : FOR ID UNTIL comparacoes VIRG sinal NUM DOISPONTOS LPAREN statements RPAREN'
    global nroFor 
    if p[2] in variaveis: 
        p[0] = r'CICLO' + str(nroFor) + ':\n' + p[4] + r'JZ FIM' + str(nroFor) + '\n' + p[10] + r'PUSHG ' + str(variaveis[p[2]]) + '\n' + r'PUSHI ' + p[7] + p[6] + '\nSTOREG ' + str(variaveis[p[2]]) + '\n' + r'JUMP CICLO' + str(nroFor) + '\nFIM' + str(nroFor) + ':\n'
        nroFor+=1

def p_cicloWhile(p):
    'while : WHILE tipos DOISPONTOS LPAREN statements RPAREN'
    global nroWhile
    aux = nroWhile +1 
    p[0] = r'L' + str(nroWhile) + ':\n' + p[2] + '\n' + r'JZ L' + str(aux) + '\n' + p[5] + '\n' + r'JUMP L' + str(nroWhile) + '\n' + r'L' + str(aux) + ':\n'
    nroWhile += 1 

def p_cicloSIf(p): 
    'ciclos : if'
    p[0] = p[1]
    global nroIf
    nroIf+=1 

def p_cicloSFor(p): 
    'ciclos : for'
    p[0] = p[1]
    global nroFor
    nroFor+=1 

def p_cicloSWhile(p): 
    'ciclos : while'
    p[0] = p[1]
    global nroWhile
    nroWhile+=1 
    
def p_printId(p): 
    'print : PRINT LPAREN ID RPAREN'
    if p[3] in variaveis: 
        p[0] = r'PUSHG ' + str(variaveis[p[3]]) + '\nSTRI\n' + r'WRITES' + '\n'
    else:
        p[0] = r'PUSHS ' + r'"Erro: Variavel desconhecida :(" '  + '\n' + r'ERR' + '\n'

def p_print(p): 
    '''print : PRINT LPAREN ASPAS ID ASPAS RPAREN
    '''
    p[0] = r'PUSHS ' + r'"' + p[4] + r'"' + '\n' + r'WRITES' + '\n'
    
def p_printN(p): 
    '''print : PRINT LPAREN ASPAS term ASPAS RPAREN
    '''
    p[0] = r'PUSHG ' + r'"' + p[4] + r'"' + '\n' + r'WRITEI' + '\n'

def p_printComposto(p): 
    '''print : PRINT LPAREN ASPAS ID ASPAS VIRG expression RPAREN
    '''
    p[0] = r'PUSHS ' + r'"' + p[4] + r'"' + '\n' +  r'WRITES' + '\n' + r'PUSHG ' + p[7] + r'WRITEI' + '\n'

def p_printExpressao(p):
    'print : PRINT LPAREN expression RPAREN'
    p[0] = p[3] + r'WRITEI' + '\n'

def p_scan(p): 
    '''scan : SCAN LPAREN ID RPAREN 
    '''
    global store
    if p[3] in variaveis: 
        p[0] = r'READ' + '\n' + r'ATOI' + '\n' + r'STOREG '  + str(variaveis[p[3]]) + '\n' 
    else: 
        p[0] = r'PUSHS "Erro: Variavel desconhecida :(" ' + '\n' + r'ERR' + '\n'

def p_return(p): 
    'devolve : RETURN LPAREN expression RPAREN'
    p[0] = p[3] + '\n' + r'PUSHS "O return é: "' + '\nWRITES\n' + 'WRITEI\n'

def p_printVirgula(p): 
    'print : PRINT LPAREN VIRG RPAREN'
    p[0] = 'PUSHS ","\n' + r'WRITES' + '\n'
    
def p_error(p):
    parser.success = False
    print('Syntax error!')

###inicio do parsing
parser = yacc.yacc()
parser.success = True

fonte = ""
for line in sys.stdin:
    fonte += line
parser.parse(fonte)

\end{lstlisting}

%-- Fim do documento -- inserção das referencias bibliográficas

%\bibliographystyle{plain} % [1] Numérico pela ordem de citação ou ordem alfabetica
%\bibliographystyle{alpha} % [Hen18] abreviação do apelido e data da publicação
%\bibliographystyle{apalike} % (Araujo, 2018) apelido e data da publicação
                             % --para usar este estilo descomente no inicio o comando \usepackage{apalike}

%\bibliography{bibLayout} %input do ficheiro de referencias bibliograficas

\end{document} 
